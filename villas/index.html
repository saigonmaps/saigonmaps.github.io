<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Saigon Maps | Villas</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link
      href="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.js"></script>
    <style>
      html,
      body,
      #map {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: sans-serif;
      }
      a {
        color: inherit;
      }
      .maplibregl-popup-content {
        background: rgba(30, 30, 30, 0.85);
        color: white;
        border: 1px solid #555;
        backdrop-filter: blur(5px);
        padding: 10px 15px;
      }
      .maplibregl-popup-anchor-bottom .maplibregl-popup-tip {
        border-top-color: rgba(30, 30, 30, 0.85);
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <script>
      // --- 1. CONSTANTS ---
      const apiKey = "8fJUltqQeAw6r7G62Ptd";
      const DATA_URL = "data.json";
      const SOURCE_ID = "villa-points-source";
      const UNCLUSTERED_LAYER_ID = "unclustered-point";
      const CLUSTERING_ENABLED = false;

      // --- 2. CONFIG ---
      const map = new maplibregl.Map({
        container: "map",
        style: `https://api.maptiler.com/maps/streets-v2/style.json?key=${apiKey}`,
        center: [106.7, 10.7769],
        zoom: 12,
        maxZoom: 24,
        maxBounds: [
          [106.3, 10.5],
          [107.1, 11.1],
        ],
        attributionControl: false,
      });

      // 2.1: Use 'load' for utils
      map.on("load", () => {
        map.addControl(
          new maplibregl.NavigationControl({
            showCompass: false,
            visualizePitch: true,
          }),
          "top-left"
        );
        map.addControl(
          new maplibregl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true },
            trackUserLocation: true,
          }),
          "top-left"
        );

        map.addControl(
          new maplibregl.AttributionControl({
            customAttribution:
              '<a href="https://threads.com/@tomeyinhanoi" target="_blank">By Tomey</a>',
            compact: true,
          }),
          "bottom-left"
        );
      });

      // 2.2: Caching
      function registerServiceWorker() {
        if ("serviceWorker" in navigator) {
          window.addEventListener("load", () => {
            navigator.serviceWorker
              .register("./sw.js", { scope: "./" })
              .then((registration) => {
                console.log(
                  "ServiceWorker registration successful with scope: ",
                  registration.scope
                );
              })
              .catch((error) => {
                console.log("ServiceWorker registration failed: ", error);
              });
          });
        }
      }
      registerServiceWorker();

      // 2.3: Use 'idle' for main workflow.
      map.once("idle", mainWorkflow);

      // --- 3. WORKFLOW ---
      async function mainWorkflow() {
        try {
          modifyBaseStyle(map); // 3.1
          const geojsonData = await loadAndParseData(DATA_URL); // 3.2
          addDataLayer(map, geojsonData); // 3.3
          addInteractivity(map); // 3.4
        } catch (error) {
          console.error("Error:", error);
        }
      }

      // 3.1: Map styling
      function modifyBaseStyle(map) {
        // console.log(
        //   "All layer ids: ",
        //   map.getStyle().layers.map((layer) => layer.id)
        // );
        const layersToRecolor = ["Grass", "Meadow", "Forest", "Wood", "Scrub"];
        const layersToHide = [
          "Residential",
          "Industrial",
          "Other border",
          "Disputed border",
        ];
        const pathsToRecolor = ["Path", "Path minor"];

        const applyProperty = (layerIds, type, key, value) => {
          layerIds.forEach((id) => {
            if (map.getLayer(id)) {
              if (type === "paint") map.setPaintProperty(id, key, value);
              if (type === "layout") map.setLayoutProperty(id, key, value);
            }
          });
        };

        applyProperty(layersToRecolor, "paint", "fill-color", "#A1E8A1");
        applyProperty(layersToHide, "layout", "visibility", "none");
        applyProperty(pathsToRecolor, "paint", "line-color", "#efeeef");

        if (map.getLayer("Building") || map.getLayer("Building 3D")) {
          map.setLayerZoomRange("Building", 16, 24);
          map.setLayerZoomRange("Building 3D", 16, 24);
        }
      }

      // 3.2: Load GeoJSON
      async function loadAndParseData(url) {
        return new Promise((resolve, reject) => {
          const worker = new Worker("./webworker.js");
          worker.onmessage = (e) => {
            worker.terminate(); // Stop the worker when done
            if (e.data.error) {
              reject(new Error(e.data.error));
            } else {
              resolve(e.data.data);
            }
          };

          worker.onerror = (e) => {
            worker.terminate();
            reject(
              new Error(`Web Worker failed to start or execute: ${e.message}`)
            );
          };

          worker.postMessage({ url });
        });
      }

      // 3.3: Data layers
      function addDataLayer(map, geojsonData) {
        // Clean up old layers anytime add new data
        ["clusters", "cluster-count", UNCLUSTERED_LAYER_ID].forEach((id) => {
          if (map.getLayer(id)) map.removeLayer(id);
        });
        if (map.getSource(SOURCE_ID)) map.removeSource(SOURCE_ID);

        const sourceOptions = {
          type: "geojson",
          data: geojsonData,
        };

        if (CLUSTERING_ENABLED) {
          sourceOptions.cluster = true;
          sourceOptions.clusterMaxZoom = 16;
          sourceOptions.clusterRadius = 50;
        }

        map.addSource(SOURCE_ID, sourceOptions);

        if (CLUSTERING_ENABLED) {
          // 1st layer: clusters
          map.addLayer({
            id: "clusters",
            type: "circle",
            source: SOURCE_ID,
            filter: ["has", "point_count"], // Only apply to features with a point_count property (i.e., clusters)
            paint: {
              "circle-color": [
                "step",
                ["get", "point_count"],
                "#51bbd6", // Blue for < 100 points
                100,
                "#f1f075", // Yellow for 100-750 points
                750,
                "#f28cb1", // Pink for > 750 points
              ],
              "circle-radius": [
                "step",
                ["get", "point_count"],
                20, // 20px radius for < 100 points
                100,
                30, // 30px radius for 100-750 points
                750,
                40, // 40px radius for > 750 points
              ],
            },
          });

          // 2nd layer: cluster number
          map.addLayer({
            id: "cluster-count",
            type: "symbol",
            source: SOURCE_ID,
            filter: ["has", "point_count"],
            layout: {
              "text-field": "{point_count_abbreviated}",
              "text-font": ["Roboto Regular", "Arial Unicode MS Regular"],
              "text-size": 12,
            },
          });
        } // 3rd layer: unclustered points
        map.addLayer({
          id: UNCLUSTERED_LAYER_ID,
          type: "circle",
          source: SOURCE_ID,
          filter: ["!", ["has", "point_count"]], // Only apply to features that are NOT clusters
          paint: {
            "circle-color": "#FF5722",
            "circle-radius": [
              "interpolate",
              ["linear"],
              ["zoom"],
              15,
              5,
              22,
              24,
            ],
            "circle-stroke-width": 1,
            "circle-stroke-color": "#fff",
          },
        });
      }

      // 3.4: Interactions
      function addInteractivity(map) {
        // Popup for unclustered points
        map.on("click", UNCLUSTERED_LAYER_ID, (e) => {
          const props = e.features[0].properties;
          const coords = e.features[0].geometry?.coordinates;
          const markerId = props.id;
          console.log(markerId);
          if (props?.address && coords) {
            map.flyTo({ center: coords, zoom: map.getZoom(), speed: 0.3 });
            const googleMapsUrl = `https://www.google.com/maps/place/${encodeURIComponent(
              props.address
            )}`;

            const popupHTML = `
                  <b>${props.address}</b>
                  <br>
                  <a href="${googleMapsUrl}" target="_blank">
                    Google Maps
                  </a>
                `;

            new maplibregl.Popup({ closeButton: false, focusAfterOpen: false })
              .setLngLat(coords) // Use coords directly
              .setHTML(popupHTML)
              .addTo(map);
          }
        });

        map.on("mouseenter", UNCLUSTERED_LAYER_ID, () => {
          map.getCanvas().style.cursor = "pointer";
        });
        map.on("mouseleave", UNCLUSTERED_LAYER_ID, () => {
          map.getCanvas().style.cursor = "default";
        });

        if (CLUSTERING_ENABLED) {
          // Click clusters to zooms in
          map.on("click", "clusters", (e) => {
            const features = map.queryRenderedFeatures(e.point, {
              layers: ["clusters"],
            });
            if (!features.length) {
              return;
            }
            const cluster = features[0];
            const pointCount = cluster.properties.point_count;
            if (pointCount <= 5) {
              const clusterId = cluster.properties.cluster_id;
              map
                .getSource(SOURCE_ID)
                .getClusterExpansionZoom(clusterId, (err, zoom) => {
                  if (err) return;
                  map.flyTo({
                    center: cluster.geometry.coordinates,
                    zoom: zoom,
                    speed: 0.6,
                    duration: 1700,
                  });
                });
            }
          });

          // Cursor = pointer
          map.on("mouseenter", "clusters", () => {
            map.getCanvas().style.cursor = "pointer";
          });
          map.on("mouseleave", "clusters", () => {
            map.getCanvas().style.cursor = "default";
          });
        }
      }
    </script>
  </body>
</html>
